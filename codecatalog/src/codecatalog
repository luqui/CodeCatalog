#!/usr/bin/python

import httplib
import urllib
import json
import sys
import webbrowser
# Begin CodeCatalog Snippet http://codecatalog.net/52/
import re
# End CodeCatalog Snippet

host = 'codecatalog.net'

def post_json(url, params):
    params_enc = urllib.urlencode(params)
    conn = httplib.HTTPConnection(host)
    headers = { "Content-type": "application/x-www-form-urlencoded",
                "Accept": "application/json" }
    conn.request('POST', url, params_enc, headers)
    response = conn.getresponse()
    if response.status != 200:
        raise IOError(str(response.status) + " " + response.reason + ":\n" + response.read())
    jsonstr = response.read()
    response.close()
    return json.loads(jsonstr)

def get_json(url, params={}):
    params_enc = urllib.urlencode(params)
    if params_enc: params_enc = '?' + params_enc
    conn = httplib.HTTPConnection(host)
    conn.request("GET", url + params_enc)
    response = conn.getresponse()
    if response.status != 200:
        raise IOError(str(response.status) + " " + response.reason + ":\n" + response.read())
    jsonstr = response.read()
    response.close()
    return json.loads(jsonstr)

# CodeCatalog Snippet http://codecatalog.net/87/
linecomment = {
    'python': '#',
    'javascript': '//',
}
# End CodeCatalog Snippet

def tag_snippet(id, code, indent="", language="python"):
    return indent + linecomment[language] + " Begin CodeCatalog Snippet http://codecatalog.net/" + str(id) + "/\n" + \
           code + \
           indent + linecomment[language] + " End CodeCatalog Snippet\n"

def check_and_update(ver, newcode):
    (newcode_norm, indent) = normalize_code(newcode)

    snip = get_json('/api/snippet/' + str(ver) + '/')
    latest = get_json('/api/snippets/' + str(snip['versionptr']) + '/active/')
    
    up_to_date = latest['version'] <= snip['version']
    changes = newcode != snip['code']

    if up_to_date:
        if changes:
            sys.stderr.write("*** Uploading changes to " + str(ver) + "\n")
            newsnip = post_json('/api/new/snippet/', {
                'spec_versionptr': snip['spec_versionptr'],
                'code': newcode_norm,
                'language': snip['language'],
                'versionptr': snip['versionptr'],
            })
            return tag_snippet(newsnip['version'], newcode, indent=indent, language=snip['language'])
        else:
            # Completely unchanged.  Don't even move your lips.
            return tag_snippet(ver, newcode, indent=indent, language=snip['language'])
    else:
        if not changes or re.match(r'^\s*$', newcode):
            sys.stderr.write("*** Downloading changes to " + str(ver) + "\n")
            return tag_snippet(latest['version'], indent_by(indent,latest['code']), indent=indent, language=latest['language'])
        else:
            sys.stderr.write("*** Snippet " + str(ver) + " is not up-to-date but has changes.  Leaving be.\n")
            return tag_snippet(ver, newcode, indent=indent)
        

def cmd_sync(*args, **opts):
    snipid = None
    code = ""
    for line in sys.stdin:
        m = re.search(r'Begin CodeCatalog Snippet http://codecatalog.net/(\d+)/', line)
        if m:
            code = ""
            snipid = int(m.group(1))
        elif snipid is None:
            sys.stdout.write(line)
        elif re.search(r'End CodeCatalog Snippet', line):
            sys.stdout.write(check_and_update(snipid, code))
            code = ""
            snipid = None
        else:
            code += line

# Begin CodeCatalog Snippet http://codecatalog.net/47/
def maximum_by(measure, xs):
    maxx = xs[0]
    maxm = measure(maxx)
    for x in xs[1:]:
        xm = measure(x)
        if xm > maxm:
            maxx = x
            maxm = xm
    return maxx
# End CodeCatalog Snippet

# Begin CodeCatalog Snippet http://codecatalog.net/61/
def initial_whitespace(line):
    return re.search(r'^\s*', line).group(0)
# End CodeCatalog Snippet

# Begin CodeCatalog Snippet http://codecatalog.net/69/
def strip_indent(text):
    indent = re.compile(r'^\s*')
    lines = text.splitlines()
    initial = min(*map(lambda l: len(initial_whitespace(l)), lines))
    return ('\n'.join(map(lambda l: l[initial:], lines)), " " * initial)
# End CodeCatalog Snippet

# Begin CodeCatalog Snippet http://codecatalog.net/71/
def indent_by(indent, text):
    return '\n'.join(map(lambda s: indent + s, text.splitlines())) + '\n'
# End CodeCatalog Snippet

def normalize_code(code):
    (s,indent) = strip_indent(code)
    return (s.strip() + "\n", indent)

def cmd_post(*args, **opts):
    name = opts.get('name') or 'unnamed'
    summary = opts.get('summary') or ''
    language = opts.get('language') or 'python'
    specid = opts.get('specid')
    quiet = opts.get('quiet')
    code = sys.stdin.read()

    (normalized, indent) = normalize_code(code)
    
    if specid is None:
        spec = post_json('/api/new/spec/', {
            'name': name, 
            'summary': summary,
        })
        specid = spec['versionptr']

    snip = post_json('/api/new/snippet/', { 
        'spec_versionptr': specid,
        'code': normalized,
        'language': language,
    })

    if not quiet:
        webbrowser.open_new_tab('http://' + host + '/spec/' + str(specid) + '/')

    sys.stdout.write(tag_snippet(snip['version'], code, indent=indent))

def cmd_get(*args, **opts):
    ver = args[0]
    ver = re.sub(r'^http://codecatalog.net/', '', ver)
    ver = re.sub(r'/$', '', ver)
    snip = get_json('/api/snippet/' + ver + '/')
    sys.stdout.write(tag_snippet(snip['version'], snip['code']))

def cmd_search(*args, **opts):
    text = ' '.join(args)
    results = get_json('/api/search/', { 'q': text })
    for result in results:
        print "/" + str(result['versionptr']) + "/", result['name'], "-", result['summary']

commands = {
    'post': cmd_post,
    'get': cmd_get,
    'sync': cmd_sync,
    'search': cmd_search,
}

def main():
    argv = sys.argv
    cmd = argv[1]
    args = []
    opts = {}
    for arg in argv[2:]:
        m = re.match(r'^--(\w+)$', arg)
        if m:
            opts[m.group(1)] = True
            continue
        m = re.match(r'^--(\w+)=(.*)$', arg)
        if m:
            opts[m.group(1)] = m.group(2)
            continue
        args.append(arg)
        
    commands[cmd](*args, **opts)

if __name__ == '__main__':
    main()
